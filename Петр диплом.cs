По данным опроса ТАСС в августе 2020 года ряд крупных вузов России отмечает высокий спрос абитуриентов на IT-специальности. Так, по данным приемных комиссий ИТМО и ИТИС минимальные баллы для поступления на бюджет в 2020 году составляли 286 и 263 соответственно [1, 2]. Действительно, данная специальность привлекательна по нескольким причинам, а именно: высокая заработная плата – средний уровень дохода по специализации варьируется от 112 до 165 тысяч рублей по данным Банка заработных плат [3]; востребованность IT-специалистов – среди IT-соискателей сохраняется низкий уровень конкуренции, даже во время пандемии в среднем по России на одну активную вакансию претендуют 3 кандидата [4]; возможность работать удаленно при необходимости. Последняя причина была подтверждена на фоне пандемии COVID-19, когда большие IT-компании смогли перевести большую часть сотрудников на удаленный формат работы, тем самым снизив риск их заражения. По данным на март 2020 года компании Тинькофф и Рамблер перевели 95% и 98% процентов своих сотрудников на дистанционный формат работы соответственно [5].
Аналогичную тенденцию показывают и платформы для дистанционного обучения. С начала пандемии COVID-19 количество онлайн-платформ с курсами по освоению новой профессии выросло более чем в 4 раза [6]. Так, по данным Skillbox, за период с марта 2020 года по настоящее время число студентов онлайн-университета возросло почти в 4,5 раза, в том числе на 30% возрос спрос на обучение разработке программного обеспечения [7].
Бурный рост числа студентов приводит к увеличению нагрузки на преподавателей при проверке задач, выполняемых в рамках практической работы. Одним из решений данной проблемы является увеличение числа проверяющих для распределения нагрузки между ними. Но такое решение напрямую зависит от ресурсов университета, образовательной площадки или курса. В свою очередь, автоматизация данного процесса не будет зависеть от количества студентов,
 
позволит снизить нагрузку на преподавателей при проверке множества похожих практических заданий и снизит общие временные издержки. Однако не все процессы могут быть автоматизированы, как например проверка кода на соответствие паттернам проектирования или проверка случайного сценария использования. Поэтому невозможно исключить преподавателя из этой цепи.
Кроме того, практическая работа студентов может представлять собой как решение отдельных практических задач, так и выполнение проектов. Проведенные исследования показали, что студенты, вовлеченные в проектную деятельность, смогли достичь высоких результатов в реализации практических умений и навыков создания программного обеспечения [8]. В проекте студенты учатся проявлять инициативу и ответственность, укреплять уверенность в себе, решать проблемы, работать в команде, передавать идеи и более эффективно управлять собой. В статье [9] рассказывается об опыте интеграции проектного обучения в курс разработки мобильных приложений. В результате опроса более 80% студентов отметили полезность проектной деятельности, выразили мнение о том, что использование такого подхода для разработки различных модулей мобильного приложения представляется наиболее подходящим и эффективным для обучения.
Целью данной работы является разработка механизмов автоматизации проверки решений задач по разработке мобильных приложений.
Для достижения данной цели были поставлены следующие задачи:
●	Реализовать модуль статического анализа исходного кода на соответствие стандартам оформления.
●	Реализовать функциональность по автоматическому запуску UI-тестов с возможностью создания снимков экрана во время выполнения.
●	Реализовать функциональность по автоматическому запуску Unit-тестов.
●	Реализовать модуль проверки на антиплагиат с другими работами студентов.
●	Реализовать модуль подготовки отчета на основе результатов предыдущих задач.
 
1	Обзор предметной области

1.1	Автоматизация процессов

В настоящее время автоматизация процессов представляет собой один из подходов к управлению процессами на основе применения информационных технологий. Данный подход позволяет осуществлять управление операциями, информацией, данными, и ресурсами за счет использования компьютеров и программного обеспечения, которые сокращают степень участия человека в процессе, либо полностью его исключают.
На сегодняшний день автоматизация процессов охватила многие отрасли промышленности и сферы деятельности: от производственных процессов, до совершения покупок в магазинах.
Стремительный рост IT-сферы заставляет находить новые способы и технологии для повышения эффективности разработки программного обеспечения. Благодаря инструментам автоматизации работа разработчиков и тестировщиков становится более комфортной, эффективной и продуктивной из-за отсутствия необходимости выполнять рутинную и повторяющуюся работу. Ярким примером автоматизации в продуктовой разработке является автоматизированное тестирование программного обеспечения. Такой подход имеет ряд преимуществ по сравнению с ручным тестированием, а именно: более короткие сроки поставки продукта, быстрое обнаружение ошибок, контроль основных функций, оптимизация использования ресурсов при выполнении повторяющихся задач.
Развитие компьютерных и инфокоммуникационных технологий также затронуло и сферу образования. Теперь ни одно учреждение не может обойтись в своей работе без применения компьютеров, которые с успехом выполняют рутинную работу, повышая эффективность любой деятельности. Данная сфера также имеет ряд решений по автоматизации процессов. Одним из примеров является переход от письменных тестов к компьютерным. Положительной стороной данного процесса является то, что студенты находятся в одинаковых условиях, исключаются элементы необъективности экзаменационного процесса.
 
Кроме того, в процессе компьютерного тестирования, обучающиеся могут оценивать собственные знания по дисциплине самостоятельно. В качестве другого примера стоит рассмотреть образовательные онлайн-платформы по обучению программированию, например курс обучения программированию на языке Python от онлайн платформы Stepik [10]. Во время обучения на курсе студенту предлагаются учебные материалы в виде лекций и примеров кода, 27 тестов и 44 практических задания. Чтобы проверить правильность выполнения практических заданий, студент загружает свой код в систему, которая автоматически проверяет правильность решения на основе заранее подготовленных тестов. Такой подход позволяет исключить ручную проверку кода преподавателем.

1.2	Обучение мобильной разработке

Рынок онлайн-образования пережил взрывной рост в 2020 году на фоне пандемии. Обучение IT-специальностям стало третьим в рейтинге самых массовых направлений онлайн-обучения, уступив только обучению иностранным языкам и маркетингу [11]. Рассматривая IT-специальности, стоит обратить внимание на сферу мобильной разработки. В 2020 году количество покупок с помощью мобильных устройств впервые превысило объем покупок с помощью компьютеров. Исходя из статистики [12] следует, что в 2021 году общее количество покупок с мобильных телефонов составит 53,9 % от общего числа онлайн-покупок. Сфера мобильной разработки остаётся актуальной и стабильно растёт, поэтому необходимость в квалифицированных специалистах сохраняется, что является дополнительным аргументом при выборе будущей специальности у студентов. В качестве другого доказательства высокого спроса и интереса со стороны студентов к данного направления рассмотрим лабораторию мобильной разработки института ИТИС КФУ. На рисунке 1 изображена диаграмма количества студентов лаборатории за последние 5 лет, которая явно показывает тенденцию роста числа студентов заинтересованных в обучении мобильной разработке.
 
 

Рисунок 1. Количество студентов в лаборатории мобильной разработки института ИТИС КФУ за последние 5 лет
На текущий момент все крупные платформы онлайн-образования используют ручную проверку решений заданий по мобильной разработке. Аналогичная ситуация наблюдается и в очном образовании. Увеличение числа студентов приводит к увеличению времени проверки решений преподавателем. Одним из вариантов решения данной проблемы является увеличение числа проверяющих, но далеко не все университеты и платформы имеют такие ресурсы. Другим вариантом решения является автоматизация.
Существуют различные решения по автоматизации проверки решений заданий по программированию, такие как “Яндекс.Контест” [13] и “Ejudge” [14], но они не подходят для проверки решений задач по мобильной разработке, так как результатом решения является мобильное приложение, соответственно необходимы инструменты, позволяющие проверять пользовательский интерфейс приложения, для проверки которых необходим эмулятор или физическое устройство.
 
2	Концепция программного инструментария

2.1	Оценивание решений

В качестве примера ручного оценивания решений задач по мобильной разработке рассмотрим процесс, который используется в лаборатории мобильной разработки института ИТИС КФУ. Данный процесс состоит из следующих этапов:
1.	Преподаватель создает репозиторий с заданием в GitHub.
2.	Студент делает копию репозитория или создает новую ветку для решения поставленных задач. Результатом решения является проект – мобильное приложение.
3.	Студент отправляет все текущие изменения, созданные в своей ветке или в копии репозитория обратно в GitHub и создает pull request (далее PR) для проверки решения преподавателем.
4.	После наступления дедлайна преподаватель клонирует решения на свой компьютер, открывает и запускает приложения студентов на эмуляторе или физическом устройстве.
Для автоматизации данного процесса проверки необходимо определить критерии оценивания решений задач, но важно понимать, не все проверки можно автоматизировать, как например проверка кода на соответствие паттернам проектирования или проверка случайного сценария использования. Для выделения наиболее значимых критериев оценивания был проведен опрос преподавателей по мобильной разработке и в результате опроса были выделены следующие критерии:
●	Код соответствует стандартам оформления.
●	В коде нет заимствований из решений других студентов.
●	Проект успешно компилируется, приложение запускается и не вылетает в процессе использования.
●	Функциональность приложения соответствует поставленным задачам.
 
2.2	Автоматизация проверки решений

Для создания инструмента по автоматизации проверки решений задач по мобильной разработке была выбрана функция GitHub Actions, позволяющая автоматизировать процесс разработки при использовании крупнейшего веб-сервиса для хостинга IT-проектов и их совместной разработки GitHub. В свою очередь GitHub Actions – это написанные пользователем сценарии, выполнение которых можно активировать по определенным событиям в репозитории: создание PR, push в ветку, наступление определенной даты и времени. Событие GitHub запускает рабочий процесс:
●	В рабочем процессе (workflow) присутствует одна или более задач (по умолчанию выполняемых параллельно).
●	Задача (job) состоит из одного или более этапов (step), выполняемых одним исполнителем (runner). Данные внутри одной задачи могут передаваться из предшествующих этапов в последующие.
●	Этап состоит из экшена и ввода этого экшена, а также допускает присвоение имени.
●	Экшен — это наименьший самостоятельный компонент рабочего процесса.
●	Исполнитель — это сервер, где установлено соответствующее приложение, которое прослушивает задачи, по очереди выполняет их, сообщает о прогрессе и логирует результаты.
Сам экшн является автономной командой, которая запускает пользовательский код или консольные команды, которые выполняют определенные действия с репозиторием на виртуальных машинах GitHub. Экшен может быть выбран из библиотеки экшенов GitHub или быть написанным самим пользователем. Файл конфигурации процесса автоматизации задается в разделе “Actions” в репозитории GitHub. На рисунке 2 представлен пример конфигурационного файла.
 
 

Рисунок 2. Пример конфигурационного файла в формате YAML

Данная функция была выбрана из-за следующих достоинств:
●	Наличие крупной библиотеки готовых экшенов.
●	Гибкая конфигурация за счет возможности использования своих экшенов и консольных скриптов.
●	Отсутствие необходимости использовать сторонние сервисы CI/CD.
В	самом	интерфейсе	GitHub	во вкладке “Actions” находится история запусков процессов автоматизации (рис. 3).

Рисунок 3. Пример истории запусков процессов автоматизации
 
При нажатии на выполненный процесс откроются его детали (рис. 4). В деталях отображено, какие шаги выполнялись, какое время занял каждый шаг и логи выполнения шагов.


Рисунок 4. Пример деталей выполненного процесса автоматизации

Для создания решения по автоматизации были разработаны механизмы – экшены, которые соответствуют критериям оценивания решений задач по мобильной разработке, полученным из проведенного опроса. Рассмотрим диаграмму компонентов решения (рис. 5).
Каждый компонент системы выполняет определенную функцию, которая определяется критерием оценивания. Так, за проверку соответствия кода стандартам оформления отвечает компонент-экшен “Linter”. Экшен тестирования запускает UI и Unit-тесты параллельно записывая экран эмулятора во время прохождения тестирования. На основе результатов экшенов тестирования и проверки кода на соответствие стандартам оформления экшен создания отчета генерирует отчет о решении студента и отправляет его в Telegram канал. Отдельным блоком выделен экшен по проверке решений на плагиат друг с другом,
 
который после выполнения отправляет отчет о процентом совпадении работ студентов.


Рисунок 5. Диаграмма компонентов механизмов автоматизации проверки решений задач
В результате весь процесс выглядит следующим образом:
1.	Преподаватель создает репозиторий с заданием в GitHub и загружает в разделе “Actions” конфигурационный файл, определяющий проверки решений.
2.	Студенты создают ветки или копии репозитория, выполняют поставленные задачи и делают PR в репозиторий преподавателя.
3.	При наступлении дедлайна запускаются два процесса:
a.	Первый процесс проверяет каждую работу на соответствие стандартам оформления и написанным тест-кейсам.
b.	Второй процесс попарно проверяет работы студентов на совпадение друг с другом.
 
4.	После завершения каждого процесса отправляется отчет о проверке в Telegram-бот преподавателя.
a.	Первый отчет содержит в себе информацию, в каких файлах и какие несоответствия стандартам оформления были допущены, какие тесты были пройдены успешно, а какие нет. Дополнительно к отчетам прикрепляется запись экрана эмулятора во время проведения тестирования.
b.	Второй отчет содержит в себе матрицу схожести решений, где значение в ячейке означает процентное сходство работ студентов.
 
3	Механизм проверки кода на соответствие стандартам оформления

3.1	Используемые технологии

Для реализации функциональности проверки кода на соответствие стандартам оформления была выбрана технология контейнеризации Docker [15] вместе с инструментом SwiftLint [16].
Docker – это программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации, контейнеризатор приложений. Данное ПО позволяет «упаковать» приложение со всем его окружением и зависимостями в контейнер, который может быть развернут на любой Linux-системе с поддержкой cgroups в ядре, а также предоставляет набор команд для управления этими контейнерами.
SwiftLint – это инструмент для обеспечения соблюдения стиля и соглашений языка Swift, основанный на ныне архивированном руководстве по стилю Swift на GitHub [17]. SwiftLint применяет правила руководства по стилю, которые обычно принимаются сообществом Swift-разработчиков.
Контейнеры Docker объединяют среду и код экшена GitHub вместе, что делает их более надежным способом упаковки. Это значит, что получателю экшена не нужно беспокоиться об инструментах или зависимостях, используемых в данном экшене.

3.2	Принцип работы

Для оптимизации временных затрат на проверку решений по нескольким критериям было принято решение запускать проверку кода на соответствие стандартам оформления и тестирование в параллельных задачах (jobs).
При возникновении события, указанного в конфигурационном файле рабочего процесса (workflow), параллельно запускаются задачи “Linter” и “XcodeTesting”.


Рассмотрим каждый шаг этой задачи. Сперва на виртуальную машину копируется репозиторий с проектом студента, который использовался для создания PR. Далее запускается непосредственно экшен использующий инструмент SwiftLint для проверки кода. После выполнения экшена последний шаг сохраняет полученный файл с отчетом о проверку в хранилище GitHub для текущего процесса.
Сам экшен проверки кода на соответствие стандартам оформления представляет из себя контейнер Docker, внутри которого устанавливается и запускается инструмент SwiftLint. Для запуска данного инструмента из командной строки сначала необходимо установить инструмент на виртуальную машину. С помощью консольных команд клонируется репозиторий инструмента из GitHub, собирается и копируется исполняемый файл в корневую папку исполняемых файлов системы виртуальной машины. Благодаря этому инструмент можно вызывать напрямую из командной строки.
После выполнения конфигурации контейнера запускается скрипт, который в свою очередь вызывает инструмент SwiftLint. В результате вызова инструмент вернет в консоль отчет, в котором содержится информация, в каких файлах допущены ошибки. Данный отчет преобразуется в формат, благодаря которому
 
ошибки отобразятся непосредственно в самом PR (рис. 6), и сохраняется в текстовый файл “SwiftLintResult.txt”.

Рисунок 6. Пример отображения несоответствия стандартам оформления в PR
 
4	Механизм тестирования

4.1	Используемые технологии

Для реализации проверки соответствия решения поставленным задачам был реализован JavaScript-экшен в связке с утилитами “xcodebuild” [18] и “xcrun simctl” [19].
Утилита “xcodebuild” обеспечивает доступ к студии Xcode [20] из терминала. Она может собирать проекты, архивировать, тестировать, анализировать. С помощью этого инструмента через командную строку производится запуск тестов.
Утилита “xcrun simctl” позволяет взаимодействовать с эмулятором iOS- устройства. Она очень похожа на утилиту “ADB” для Android, устанавливается вместе со средой разработки Xcode и используется вместе с “xcrun” (Xcode-раннер командной строки). Список доступных команд этой утилиты содержит инструкцию для запуска записи экрана эмулятора.
Выбор языка JavaScript для написания экшена обусловлен тем, что технология Docker не поддерживает операционную систему macOS в контексте GitHub Actions, а студия Xcode, которая предоставляет данные утилиты, работает только с данной версией операционной системы.
Таким образом, при использовании двух вышеупомянутых инструментов можно получить данные о результатах тестирования вместе с записью экрана во время выполнения этих тестов.

4.2	Принцип работы

Как было отмечено ранее, запуск экшена тестирования происходит одновременно и параллельно на отдельной виртуальной машине вместе с задачей по проверке кода на соответствие стандартам оформления.
При возникновения события, указанного в конфигурационном файле рабочего процесса (workflow), запускается задача “XcodeTesting” (рис. 7).
 
 

Рисунок 7. Диаграмма последовательности задачи тестирования

Рассмотрим каждый шаг этой задачи. Сперва на виртуальную машину копируется репозиторий с проектом студента, который использовался для создания PR. Далее запускается непосредственно экшен тестирования. Для получение отчета о результатах тестирования вместе с записью экрана, необходимо передать в экшене следующие обязательные параметры:
●	“result-bundle-path” – путь, по которому будет находиться отчет о результатах прохождения тестов;
●	“screen-record-bundle-path” – путь, по которому будет находиться запись экрана во время прохождения тестов.
Перед началом тестирования происходит валидация входных параметров для последующего составления консольной команды по запуску тестирования. Для запуска эмулятора из командной строки необходим уникальный идентификатор (UDID) девайса. Так как пользователь передает в экшен только название девайса и версию его операционной системы, есть возможность найти
 
UDID необходимого девайса с помощью списка всех девайсов, установленных на виртуальной машине.

После валидации посредством нескольких команд происходит запуск эмулятора на виртуальной машине.
Так как Xcode не предоставляет нативного решения для записи экрана во время тестирования приложения, был разработан способ, позволяющий достичь заданной цели. После запуска симулятора отдельной командой запускается новый терминал с командой запуска записи экрана. Команда запускает процесс, который ждет команду для завершения записи экрана, а именно комбинацию Ctrl+C для мягкого завершения процесса.

После этого в первом терминале выполняется команда по запуску тестирования. Для окончания записи экрана эмулятора необходимо остановить процесс, который отвечает за запись экрана. Получив результаты тестирования, с помощью консольной команды находится и завершается процесс записи.

Результатом выполнения тестирования будут два файла: отчет со всей информацией о тестировании в формате “.xcresult” и запись экрана в формате “.mp4”.
Прежде чем приступить к экшену формирования отчета, необходимо подготовить, распарсить, данные о тестировании. Для этого было написано консольное приложение на Swift, на вход которого подается путь до файла в формате “.xcresult”. В результате выполнения приложения пользователь увидит результаты тестирования в текстовом виде. В шаге “Parse .xcresult”, отвечающий
 
за парсинг файла в формате “.xcresult”, выполняется консольный скрипт, в котором скачивается последняя версия парсера, собирается, устанавливается и запускается с путем до отчета тестирования. Результат выполнения приложения сохраняется в текстовом формате “.txt”.
Последним этапом в шаге “XcodeTesting” является сохранения текстового файла результата тестирования и видео записи экрана во время тестирования в виде артефактов для дальнейшего использования в экшене создания отчета о проверке решения студента.
 
5	Механизм формирования отчета

Для получения отчета о результатах проверки кода на соответствие стандартам оформления и результатах прохождения тестов необходимо было реализовать дополнительный экшен, который создаст отчет на основе данных от предыдущих задач “Linter” и “XcodeTesting” .
Реализация выполнена с помощью технологии контейнеризации Docker в паре со скриптом, написанном на Python. Для работы экшена необходимо передать три параметра: путь до файла с результатами тестирования, путь до файла с результатами проверки кода на соответствие стандартам оформления и имя автора автора решения.
 
Результатом работы экшена является текстовый файл, который содержит в себе текст отчета для сообщения, которое будет отправлено в Telegram. Рассмотрим всю задачу (job), отвечающую за процесс генерации и отправки отчета.
ReportCreator:
Рассмотрим каждый шаг этой задачи. Сперва на виртуальную машину загружаются отчеты о проверки линтера и прохождения тестирования из хранилища артефактов процесса. Далее вызывается экшен, в который передаются пути загруженных артефактов и имя автора, сделавшего PR. После выполнения
 
экшена вызывается экшен отправки сообщения в Telegram. В качестве входных данных передается токен авторизации бота, от имени которого будут отсылаться отчеты, идентификатор канала, файл с текстом сообщения и формат текста сообщения.
В результате выполнения данной задачи в канал, идентификатор которого указан при конфигурации шага вызова экшена отправки сообщения в Telegram, отправляется сообщение-отчет с результатами проверки кода на соответствие стандартам оформления и прохождением тестирования вместе с записью экрана (рис. 8).


Рисунок 8. Пример отчета в канале Telegram
 
6	Проверка решений на наличие заимствований

6.1	Механизм проверки

Для реализации функционала определения наличия заимствований кода между решениями студентов был написан экшен на основе технологии контейнеризации Docker вместе с со скриптами на языке Python.

Рассмотрим файл конфигурации экшена. Для использования экшена необходимо указать два обязательных параметра:
●	“github-access-token” – токен доступа к функциям GitHub;
●	“repository-name” – название репозитория в формате “владелец репозитория/название репозитория”.
Токен и название репозитория необходимы для получения PR-решений студентов. Для создания контейнера Docker необходим Dockerfile, который описывает требования к контейнеру.
Для реализация проверки решений было найдено два инструмента:
1.	Облачный сервис по проверке кода и текстов на плагиат “Copyleaks” [21]. Данный сервис позволяет проверять файлы формата .swift.
2.	Программа на языке C для нахождения совпадений между текстовыми документами под названием “Sherlock” [22].
Облачный сервис имеет множество преимуществ такие как:
●	Поиск похожих решений в интернете.
●	Сравнение	решений	друг	с	другом	среди	решений,	загруженных пользователем.
●	Большое количество поддерживаемых языков, в том числе и Swift.
Но есть недостаток, который не позволяет использовать данный сервис – пробная версия не позволяет сравнивать файлы программ на плагиат, а платная версия стоит от 35$ в месяц. В связи с этим было отдано предпочтение программе “Sherlock”. Данная программа использует цифровые подписи для поиска похожих фрагментов текста. Цифровая подпись – это число, которое формируется путем преобразования нескольких слов во входных данных в серию битов и объединения этих битов в число. “Sherlock” работает с текстовыми файлами, такими как эссе, файлами исходного кода и другими заданиями в цифровой форме.
 
 

Рисунок 9. Диаграмма последовательности задачи проверки решений на плагиат

После установки Python версии 3.8 и копирования необходимых файлов запускается bash-скрипт “entrypoint.sh” (рис. 9). Первым шагом необходимо скомпилировать программу по нахождению плагиата.

После получения всех решений студентов необходимо обработать полученные директории с файлами. Для запуска программы по нахождению соответствий необходимо передать в качестве параметров директории с файлами для сравнения. Директории должны содержать только файлы для сравнения без других директорий и файлов в других форматах. Для этого необходимо перенести
 
все файлы из дочерних директорий в скачанную корневую директорию решения студента и оставить только файлы с расширением “.swift”.

После	подготовки	директорий	запускается	программа	“Sherlock”	и сравнивает файлы друг с другом между директориями с решениями студентов.

В	результате	выполнения	программы	получаем	файл	“result.txt”	со сравнениями файлов.
После	получения	результата	сравнения	файлов	запускается	скрипт “parser.py”, который создает матрицу схожести решений (рис. 10).




Рисунок 10. Пример матрицы схожести решений
 
В ячейках матрицы содержится значение, которое показывает схожесть двух решений, где значение равное 0 означает, что в коде нет заимствований в сравнении с другим решением, а 1 – код полностью совпадает с решением другого студента.


6.2	Конфигурация процесса

Для запуска проверки решений на наличие заимствований была создана отдельная конфигурация в целях снизить количество запусков. В отличии от процесса проверки каждого решения на соответствие стандартам оформления и получения результатов тестирования, где запуск происходит для каждого решения, процесс проверки на заимствования достаточно запустить один раз, так как внутри экшена происходит сравнение всех решений разом.
Рассмотрим файл конфигурации процесса проверки решений на плагиат. Данный процесс запускается по графику, установленному преподавателем, в данном случае в 23:59 каждое воскресенье. Первым шагом процесса является запуск экшена проверки решений на плагиат. Для этого передаются два параметра: токен доступа GitHub и название репозитория с заданием. После выполнения выполняется шаг по сохранению результатов проверки в хранилище артефактов GitHub и выполнение экшена отправки матрицы схожести решений в Telegram-канал (рис. 11).


Рисунок 11. Пример отправленного результата о проверке решений на плагиат
 
7	Примеры использования

7.1	Настройка репозитория

Для использования разработанных механизмов в первую очередь преподавателю необходимо создать репозиторий с задачей, от которого студенты будут создавать ветки или копии репозитория.
После создания репозитория с заданием необходимо добавить в раздел зашифрованных переменных в настройках репозитория следующие переменные (рис. 12):
●	ACCESS_TOKEN	–	токен	доступа	GitHub,	позволяющий	запрашивать информацию о пользователе и репозиториях.
●	TELEGRAM_TO – идентификатор канала, в который будут отправляться отчеты о проверках.
●	TELEGRAM_TOKEN	–	токен	доступа	бота,	от	имени	которого отправляются сообщения в канал с отчетами.


Рисунок 12. Зашифрованные переменные репозитория

После добавления зашифрованных переменных репозитория необходимо добавить в разделе “Actions” (рис. 13) два файла конфигурации процессов в формате YAML, приведенных в приложениях А.1 и А.2 к тексту работы.
 
 

Рисунок 13. Раздел “Actions” для создания новой конфигурации процесса в панели управления репозиторием


7.2	Варианты отчетов

В зависимости от результатов проверки кода на соответствие стандартам оформления, итоговый отчет содержит разные варианты отображения несоответствия стандартам оформления. Данные несоответствия имеют два режима отображения: замечания (рис. 14) и ошибки (рис. 15).




 
Рисунок 14. Вариант отчета с замечаниями
 
Рисунок 15. Вариант отчета с ошибками
 
Для результатов тестирования также существует два варианта отображения: отображение непройденных тестов вместе с причиной (рис. 16) и успешное прохождение всех тестов (рис. 17).


 
Рисунок 16. Вариант отчета с не пройденными тестами
 
Рисунок 17. Вариант отчета с успешным прохождением тестов
 

Также	на	рисунке	17	представлен	вариант	отчета,	когда	решение соответствует стандартам оформления и все тесты пройдены успешно.
 
Заключение

В результате выполнения данной дипломной работы была достигнута цель – разработаны механизмы автоматизации проверки решений задач по разработке мобильных приложений.
Для достижения поставленной цели были реализованы следующие задачи:
●	Реализован механизм проверки кода на соответствие стандартам оформления на основе созданного GitHub-экшена с помощью технологии Docker.
●	Реализован механизм тестирования с помощью созданного GitHub-экшена по запуску UI и Unit-тестирования с возможностью записи экрана эмулятора во время проведения тестирования.
●	Реализован механизм формирования отчета с помощью GitHub-экшена подготовки и отправки отчета в Telegram-канал на основе результатов экшенов проверки исходного кода на соответствие стандартам оформления и тестирования.
●	Реализована проверка решений студентов на плагиат с помощью написанного GitHub-экшена на основе технологии Docker, возвращающий матрицу с процентными совпадениями решений.
Разработанное программное решение позволяет снять часть нагрузки с преподавателя во время проверки решений задач по мобильной разработке по сравнению с ручной проверкой. Данные механизмы позволяют проверить решения на соответствие следующим критериям:
●	В коде нет заимствований решений других студентов.
●	Код соответствует стандартам оформления.
●	Проект успешно компилируется, приложение запускается и не вылетает в процессе использования.
●	Функциональность приложения соответствует поставленным задачам.
 
Результаты выполнения данной выпускной квалификационной работы опубликованы в открытом доступе на GitLab и доступны по ссылке: http://gititis.kpfu.ru/Shakhova/VKR_PSNovoselov.
